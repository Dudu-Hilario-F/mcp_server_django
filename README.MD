# Projeto MCP-Docs: Meu Co-piloto Pessoal para a Documenta√ß√£o do Django

Reposit√≥rio do MCP-Docs.

A ideia nasceu de uma necessidade minha. Eu sempre acabava perdendo um temp√£o com `Ctrl+F` na documenta√ß√£o do Django, pulando de p√°gina em p√°gina. 
Pensei: "e se eu pudesse ter uma busca mais inteligente, que entendesse o *problema* que eu quero resolver, em vez de s√≥ as palavras exatas que eu digito? e trazer uma solu√ß√£o profissional baseado no manual do problema".

Foi assim que decidi criar o **MCP-Docs**, um servidor que estuda a documenta√ß√£o do Django e a deixa prontinha para ser consultada por qualquer IA que esta utilizando no momento. 
A meta √© ter um co-piloto que me d√™ respostas diretas e contextuais sobre a documenta√ß√£o que me ajude a resolver um determinado problema e testar o novo produto do google `Gemeni CLI`.

## ü§î A Ideia: Por que esse projeto existe?

O objetivo que tracei foi simples: criar um sistema que:
1.  Lesse a documenta√ß√£o oficial do Django por conta pr√≥pria.
2.  Guardasse esse conhecimento de uma forma "inteligente", com contexto.
3.  Disponibilizasse uma API para que um cliente de IA pudesse fazer perguntas e me dar as respostas.

A miss√£o: aposentar o `Ctrl+F` e buscar por **significado** na internet e foruns e me dar uma resposta mais precisa para melhorar minha produtividade na linguagem em que o projeto esta sendo desenvolvido.

### üßê Mas... a IA n√£o podia fazer tudo isso sozinha?

Uma d√∫vida gigante que voc√™ pode esta pensando agora: 
`"Se o Gemini √© t√£o inteligente, por que eu preciso construir todo esse sistema? Ele n√£o poderia simplesmente ir ao site do Django e encontrar as respostas sozinho?".`

A resposta √© **n√£o**, e entender o porqu√™ √© entender o motivo pelo qual o MCP-Docs √© t√£o √∫til.

Pensei nisso da seguinte forma: a IA √© como um professor universit√°rio genial, que leu uma biblioteca inteira de livros at√© o dia em que se formou. Ele sabe MUITO, mas sobre o que ele estudou **at√© aquela data**.

* **Conhecimento Geral (O Professor Genial):** A "mem√≥ria" da IA √© baseada no seu treinamento. Ela pode me dar √≥timas respostas sobre o Django 4.0, por exemplo. Mas se eu perguntar sobre uma nova funcionalidade do Django 5.2, ou uma que mudou recentemente, a mem√≥ria dele pode estar desatualizada. Pior, ele pode tentar "adivinhar" a resposta e me passar uma informa√ß√£o incorreta (o que o pessoal chama de "alucina√ß√£o"), e em programa√ß√£o, um detalhe errado pode custar horas de dor de cabe√ßa.

* **Ferramenta Espec√≠fica (Meu Servidor MCP-Docs):** O meu servidor √© como um **assistente de laborat√≥rio especializado**. O professor genial (a IA) n√£o vai at√© a biblioteca procurar os artigos mais recentes. Ele vira para o assistente e diz: "V√° at√© a prateleira da 'Documenta√ß√£o do Django 5.2' e me traga o texto exato sobre `OneToOneField`".

O meu servidor MCP-Docs √© esse assistente. Ele n√£o tem a intelig√™ncia do professor para conversar, mas ele tem uma √∫nica tarefa que faz perfeitamente: ir at√© a **minha base de dados, que eu mantenho atualizada**, e trazer a informa√ß√£o crua, factual e correta.

#### A Parceria Perfeita: RAG (Retrieval-Augmented Generation) Gera√ß√£o Aumentada por Recupera√ß√£o.

1.  **Recupera√ß√£o (Retrieval):** A IA, ao inv√©s de adivinhar, usa minha ferramenta (o MCP-Docs) para **recuperar** a informa√ß√£o precisa e atualizada.
2.  **Gera√ß√£o Aumentada (Augmented Generation):** Com essa informa√ß√£o confi√°vel em m√£os, a IA usa sua genialidade para **aumentar** a qualidade da sua resposta. Ela n√£o apenas me joga o texto da documenta√ß√£o, mas o interpreta, resume e me explica no contexto da minha pergunta original.

Ent√£o, o MCP-Docs n√£o √© um concorrente da IA; ele √© o melhor amigo dela. Ele entrega a informa√ß√£o fresca e confi√°vel, e a IA usa seu poder de racioc√≠nio para transformar essa informa√ß√£o em uma resposta perfeita. √â a melhor colabora√ß√£o poss√≠vel!


## üå± Mantendo o Conhecimento Fresco: Como Atualizar a Base de Dados

Beleza, o MCP-Docs est√° funcionando e a busca sem√¢ntica √© incr√≠vel. Mas a√≠ bateu outra d√∫vida: o Django lan√ßa uma nova vers√£o, ou uma p√°gina da documenta√ß√£o √© corrigida. Como eu garanto que o meu co-piloto n√£o fique "congelado no tempo" com informa√ß√£o velha?

A resposta √© que eu preciso de um processo para **re-popular** e **atualizar** o banco de dados. Existem duas abordagens pra isso: a manual (que j√° funciona) e a autom√°tica (o plano pro futuro).

### Como a "M√°gica" da Atualiza√ß√£o Funciona

Antes de mais nada, uma coisa que eu j√° tinha preparado no c√≥digo √© que o script de importa√ß√£o √© **inteligente para lidar com atualiza√ß√µes**.

* No banco de dados do Django, eu usei o comando `update_or_create()`. Isso significa: "Se o `source_url` deste chunk de documento j√° existe, **atualize** o conte√∫do. Se n√£o existe, **crie** um novo."
* No ChromaDB, eu usei o comando `upsert()`. Ele faz exatamente a mesma coisa: se o ID do chunk j√° existe, o vetor de embedding √© atualizado; sen√£o, um novo √© inserido.

Esses dois comandos s√£o os her√≥is silenciosos aqui, pois eles garantem que eu n√£o crie conte√∫do duplicado e que as informa√ß√µes sejam sempre substitu√≠das pelas mais recentes.

### Abordagem 1: A Atualiza√ß√£o Manual (O Jeito Simples e Direto)

Este √© o m√©todo que eu posso usar agora mesmo, sempre que eu notar uma mudan√ßa importante ou quiser adicionar mais conhecimento.

1.  **Encontre a P√°gina:** Primeiro, eu encontro a URL da p√°gina da documenta√ß√£o do Django que foi atualizada ou que eu quero adicionar.
2.  **Rode o Comando:** Eu simplesmente executo o comando `import_docs`, apontando para essa p√°gina.

    ```bash
    # Exemplo: A documenta√ß√£o sobre "Formsets" foi atualizada na vers√£o 5.2
    python manage.py import_docs 5.2 topics/forms/formsets/
    ```

O script vai fazer todo o trabalho pesado. Ele vai ler a p√°gina, e o `update_or_create` / `upsert` v√£o garantir que os chunks sejam atualizados ou criados no banco de dados, sem bagun√ßa.

> **Dica de Mestre:** Para uma atualiza√ß√£o massiva (como o lan√ßamento do Django 6.0), a abordagem mais segura seria apagar o banco de dados antigo (`db.sqlite3`) e a pasta `chroma_db/`, rodar o `migrate` de novo, e ent√£o re-popular tudo do zero com a nova vers√£o. Isso garante uma base de conhecimento 100% limpa e consistente.

### Abordagem 2: A Atualiza√ß√£o Autom√°tica (O Pr√≥ximo N√≠vel)

Ainda estudando.

...

## üõ†Ô∏è Ferramentas: O que eu usei no projeto

Para tirar essa ideia do papel, precisei aprender e usar algumas ferramentas. Cada uma foi uma pe√ßa chave no quebra-cabe√ßa:

* **Django**: Foi a base de tudo, o "chassi" do meu projeto. Usei pra criar o servidor, o banco de dados principal e organizar a estrutura.
* **Django REST Framework (DRF)**: O kit de ferramentas que me ajudou a construir a "ponte" (a API) entre meu servidor e o mundo. Sem ele, criar a API teria sido bem mais complicado.
* **Requests**: A ferramenta que meu "rob√¥" usou pra ir at√© o site do Django e baixar o conte√∫do das p√°ginas. Simples e eficaz.
* **BeautifulSoup4**: Depois que o `requests` trazia o HTML, o BeautifulSoup foi meu detetive particular, analisando a "sopa" de tags e me ajudando a extrair s√≥ o texto que importava.
* **Sentence-Transformers**: A "varinha m√°gica" do projeto. Essa biblioteca pegou o texto puro que extra√≠ e o transformou em "embeddings" ‚Äì basicamente, matem√°tica que representa o significado do texto. √â aqui que a IA do projeto come√ßou a tomar forma.
* **ChromaDB**: Se os embeddings s√£o o conhecimento, o ChromaDB foi a "estante de livros m√°gica". Ele organiza os textos por similaridade de significado, o que permite buscas por contexto de forma super r√°pida.

## üöÄ Como Colocar pra Rodar: Guia de Instala√ß√£o

Quer testar o projeto a√≠? √â s√≥ seguir esses passos:

1.  **Clone o reposit√≥rio:**
    ```bash
    git clone [https://github.com/seu-usuario/seu-repositorio.git](https://github.com/seu-usuario/seu-repositorio.git)
    cd seu-repositorio
    ```

2.  **Crie e ative seu ambiente virtual:**
    ```bash
    python -m venv mcp-env
    # No Windows: mcp-env\Scripts\activate
    # No macOS/Linux: source mcp-env/bin/activate
    ```

3.  **Instale as depend√™ncias:**
    ```bash
    # (Seria necess√°rio criar um requirements.txt com as libs acima)
    pip install django djangorestframework requests beautifulsoup4 sentence-transformers chromadb
    ```

4.  **Prepare o banco de dados:**
    ```bash
    python manage.py migrate
    ```

5.  **Alimente a base de conhecimento:** Rode o scraper para ler a documenta√ß√£o e criar os embeddings.
    ```bash
    # Rode para quantas p√°ginas da documenta√ß√£o voc√™ quiser!
    python manage.py import_docs 5.2 topics/db/models/
    ```

6.  **Inicie o servidor:**
    ```bash
    python manage.py runserver
    ```

## üó∫Ô∏è Minha Jornada: O Di√°rio de Bordo do Projeto

O projeto foi uma escada, degrau por degrau.

#### Etapa 1: O Esqueleto (Setup do Django)
Aqui foi onde tudo come√ßou. A parte de planejamento, definindo a estrutura de pastas e o primeiro modelo no `models.py`, o `DocumentChunk`. Foi o molde para cada peda√ßo de conhecimento que eu ia guardar.

#### Etapa 2: O Ca√ßador de Conhecimento (Web Scraper)
Essa foi a hora de botar a m√£o na massa. Criei um comando Django (`import_docs`) que usava `requests` e `BeautifulSoup` para ca√ßar o conte√∫do na documenta√ß√£o. O desafio foi ensinar o script a se comportar como um detetive: achar o conte√∫do principal, quebr√°-lo em se√ß√µes l√≥gicas e salvar no banco de dados.

#### Etapa 3: A Ponte para o Mundo (API com Busca Simples)
Com os dados guardados, eu precisava de um jeito de acess√°-los. Usando o DRF, constru√≠ a primeira vers√£o da API. Criei um `Serializer` pra "traduzir" os dados pra JSON e uma `View` que fazia uma busca simples por texto. O primeiro teste no navegador, vendo o JSON aparecer, foi um momento de vit√≥ria.

#### Etapa 4: Dando um C√©rebro ao Projeto (Embeddings e Busca Sem√¢ntica)
A grande virada. Modifiquei o scraper para, al√©m de salvar o texto, usar a `sentence-transformers` para criar um vetor de embedding para cada peda√ßo. Esse vetor, que √© puro significado, foi salvo no `ChromaDB`. Depois, refiz a API. Agora, em vez de buscar por palavras, ela transforma a pergunta em um vetor e pede ao ChromaDB os textos com os significados mais parecidos. Foi aqui que o projeto ganhou vida.

## ü§Ø Os Quebra-Cabe√ßas: Dificuldades que Encontrei

Nem tudo foram flores! Tive cada dor de cabe√ßa que me ensinou muito.

1.  **O Site que Muda:** Meu primeiro grande erro foi achar que a estrutura do site do Django era sempre igual. O scraper quebrou feio porque o seletor que eu usava (`div#content`) n√£o existia mais. **Aprendizado:** Aprendi na marra que a melhor forma de debugar um scraper √© salvando o HTML que ele baixa e investigando o arquivo como um detetive. Foi assim que achei o seletor correto (`article#docs-content`).

2.  **O Fantasma do C√≥digo Antigo:** Passei um tempo frustrado porque eu mudava o c√≥digo, mas o erro continuava o mesmo. **Aprendizado:** Descobri duas pegadinhas cl√°ssicas do Python. A primeira era **indenta√ß√£o** errada (um `def` fora do lugar quebra tudo). A segunda era o **cache de bytecode (`__pycache__`)**. O Python estava rodando uma vers√£o antiga do meu script. A solu√ß√£o? Deletar as pastas `__pycache__` e reiniciar o terminal. Foi como um exorcismo!

3.  **Ser Educado com o Servidor:** No come√ßo, o site do Django bloqueava meu script. **Aprendizado:** Descobri que um script n√£o pode chegar "chutando a porta". Adicionei um `User-Agent` para ele se apresentar como um navegador comum, e os servidores me deixaram entrar.

## üîå Como Usar: Integrando o MCP-Docs com um Cliente de IA (Gemini)

Beleza, o servidor est√° pronto, a API funciona. E agora? Como um "usu√°rio do MCP" faz isso virar um assistente de verdade?

A ideia √© que a nossa API n√£o foi feita para um humano usar diretamente no navegador. Ela foi feita para ser uma **"ferramenta" (tool)** para um modelo de linguagem grande (LLM), como o Gemini.

√â como dar um superpoder para a IA. Por padr√£o, ela tem o conhecimento geral dela. Ao registrar nossa API como uma ferramenta, a gente ensina pra ela:

> "Olha, Gemini, quando algu√©m te perguntar algo **espec√≠fico e t√©cnico sobre a documenta√ß√£o do Django**, n√£o tente adivinhar. Use esta ferramenta que eu criei, que se chama `search_django_docs`, porque ela tem a informa√ß√£o mais atualizada."

#### Passo 1: Definir a Ferramenta (A "Declara√ß√£o")

No seu cliente (seja a Gemini CLI ou um script Python que usa a API do Gemini), voc√™ precisa declarar a ferramenta. √â um tipo de "contrato", geralmente em formato JSON, que descreve o que sua ferramenta faz.

**Exemplo de como seria essa declara√ß√£o:**

```json
{
  "name": "search_django_docs",
  "description": "Busca na documenta√ß√£o oficial do Django por trechos de texto que respondam a uma pergunta ou descrevam um conceito t√©cnico.",
  "parameters": {
    "type": "object",
    "properties": {
      "q": {
        "type": "string",
        "description": "A pergunta do usu√°rio ou o conceito a ser pesquisado. Deve ser uma frase completa para uma busca sem√¢ntica eficaz."
      }
    },
    "required": ["q"]
  }
}
```
`name:` O nome que a IA vai usar para chamar a ferramenta.

`description:` A explica√ß√£o para a IA entender quando usar a ferramenta.

`parameters: ` Descreve os "argumentos" que a ferramenta precisa. No nosso caso, apenas o par√¢metro q.

#### Passo 2: A M√°gica Acontecendo (O Fluxo)
Uma vez que a ferramenta est√° registrada no seu cliente Gemini, o fluxo √© o seguinte:

Voc√™ Pergunta: Voc√™ digita na sua CLI: "Ei, Gemini, qual a diferen√ßa entre OneToOneField e ForeignKey no Django?"

A IA Decide: O Gemini analisa sua pergunta. Por causa da descri√ß√£o da nossa ferramenta, ele entende que a melhor forma de responder n√£o √© com seu conhecimento geral, mas sim consultando a documenta√ß√£o. Ele decide usar a ferramenta search_django_docs.

A IA Prepara a Chamada: Ele pega sua pergunta e a formata como o par√¢metro q da nossa API.

O Cliente Executa: Seu cliente (a CLI) faz a chamada HTTP de verdade para o nosso servidor: GET http://127.0.0.1:8000/api/v1/search/?q=diferen√ßa entre OneToOneField e ForeignKey

Nosso Servidor Trabalha: Nosso MCP-Docs recebe a chamada, transforma a pergunta em um vetor, busca no ChromaDB os chunks mais relevantes e os retorna como JSON.

A Resposta da Ferramenta: Seu cliente recebe esse JSON e o envia de volta para a IA, dizendo: "Ok, Gemini, o resultado da ferramenta foi este aqui..."

A IA Sintetiza: Agora vem a melhor parte. O Gemini n√£o te joga o JSON na tela. Ele l√™ os trechos da documenta√ß√£o que nosso servidor enviou, entende o conte√∫do e formula uma resposta final, coesa e em linguagem natural para voc√™.

No final, voc√™ tem uma resposta inteligente, baseada na documenta√ß√£o mais recente, tudo de forma autom√°tica. Esse √© o poder de conectar um LLM a ferramentas personalizadas.
